# Modifying CAViewer

Compiling from source
=====================
CAViewer v2 uses JavaFX. You will need to download JavaFX from https://gluonhq.com/products/javafx/. <br>
Then, compile to a *.jar using FakeMain.java.

For more detailed steps, look for a tutorial on how to compile JavaFX programs, 
such as this [one](https://medium.com/@vinayprabhu19/creating-executable-javafx-application-part-2-c98cfa65801e). <br>

Modifying the Application
=========================
Follow the instructions above and download Java & JavaFX.
If you want to modify the GUI of the main windows, you will also require 
[SceneBuilder](https://gluonhq.com/products/scene-builder/).

Modifying the GUI
-----------------
CAViewer uses the MVC or Model, View, Controller framework. <br>
Model contains the classes the run the simulation as well as search programs. <br>
Controller contains the event handling classes and the dialogs. <br>
View contains the resources needed to render the application such as the *.fxml files and icons. <br>

main.fxml contains the GUI of the main window. Open it in Scene Builder to modify it. <br>
Events from main.fxml are handled by MainController.java. See the comments in MainController.java for more details<br>

Adding custom rule families
---------------------------
All custom rules families will inherit from the abstract RuleFamily class in 
[RuleFamily.java](src/sample/model/RuleFamily.java).

The rule families must use rulestrings to store data. 
They will need to generate regexes to help differentiate them from other rules families<br>
Any additional data that cannot be feasible stored in a rulestring will need to be generated as RLE comments and 
they will be appended to the RLE pattern files.

They must implement the following methods
```java
public abstract class RuleFamily extends Rule implements Cloneable {
    // Loads the rulestring
    public abstract void fromRulestring(String rulestring);

    // Canonises the rulestring
    public abstract String canonise(String rulestring);

    // Returns the regexes to identify the rule family
    public abstract String[] getRegex();

    // Get description of this rule family
    public abstract String getDescription();

    // Randomise rule between minimum and maximum rules
    // Throw IllegalArgumentException if the rule families are not the correct type
    public abstract void randomise(RuleFamily minRule, RuleFamily maxRule) throws IllegalArgumentException;

    // Output false if not successful, true if successful
    // Generates apgtable for apgsearch to use
    // Throw UnsupportedOperationException if this operation is not supported
    public abstract boolean generateApgtable(File file) throws UnsupportedOperationException;

    // Generates comments that will be placed in the RLE
    // These comments represent additional information that is not stored in the rulestring (e.g. weights)
    // Returned array to be something like {"#C 1 2 3 2 1", "#C 2 4 6 4 2"}
    public abstract String[] generateComments();

    // Loads the RLE comments that are generated by generateComments
    public abstract void loadComments(String[] comments);
}
```

as well as these methods from the abstract [Rule.java](src/sample/model/Rule.java).
```java
public abstract class Rule {
    public abstract Coordinate[] getNeighbourhood(int generation);
    public abstract int transitionFunc(int[] neighbours, int cellState, int generations);
    
    // May be helpful to override for specific cases
    public Color getColor(int state);  // Override for custom colour palette
    public void step(Grid grid, HashSet<Coordinate> cellsChanged, int generation);  // Override for more specific stuff
}
```

For example, take a look at the rule families found [here](src/sample/model/rules).

Then, create a rule dialog that extends from the abstract [RuleWidget.java](src/sample/controller/dialogs/RuleWidget.java).

It will need to implement the following method which updates the *ruleFamily* attribute with the relevant information.
```java
public abstract class RuleWidget extends GridPane {
    // Updates the rule with the necessary information
    public abstract void updateRule(String rulestring);
}
```

You may also add other widgets as part of this rule dialog. Some useful predefined widgets would be:
- [x] [NeighbourhoodSelector.java](src/sample/controller/NeighbourhoodSelector.java)
- [ ] State Weights Selector

Adding custom neighbourhoods types
----------------------------------
1. Add a generator function in [NeighbourhoodGenerator.java](src/sample/model/NeighbourhoodGenerator.java). 
It should generate an array of Coordinates.
2. Add a new case in the switch in the *generateFromSymbol* method.
3. If the neighbourhood has weights, add another generator function for the weights. 
It should generate an array of integers which correspond to the weights of each of the 
coordinates in the first generator function.
4. Add a new case in the switch in the *generateWeightsFromSymbol* method.
5. Finally, add the symbol used to the static *neighbourhoodSymbols* variable.
