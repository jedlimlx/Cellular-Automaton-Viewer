# Modifying CAViewer

Note that this contains outdated information.

Compiling from source
=====================
CAViewer v2 uses JavaFX and Gradle.

To run the application without the executables, you will first need to install the JDK. <br>

To build a cross-platform fat jar, run `gradlew build --build-file build2.gradle`. <br>
The jar will be generated in build/libs. This jar will be able to run on Linux, Mac and Windows. <br>

To build a platform dependent exectuable, run `gradlew build`. <br>
Note that this requires JDK 14 or higher. <br>
Afterwards, the exectuable will be generated in build/jpackage. <br>

Changing *skipInstaller* from *true* to *false* will generate an installer instead.
On Windows, this will require that you have the [WiX Toolset](https://wixtoolset.org/) installed.

Modifying the Application
=========================
Follow the instructions above and make sure the JDK is installed.
If you want to modify the GUI of the main windows, you will also require 
[SceneBuilder](https://gluonhq.com/products/scene-builder/).

Modifying the GUI
-----------------
CAViewer uses the MVC or Model, View, Controller framework. <br>
[Model] contains the classes the run the simulation as well as search programs. <br>
[Controller] contains the event handling classes and the dialogs. <br>
[Resources] contains the resources needed to render the application such as the *.fxml files and icons. <br>

main.fxml contains the GUI of the main window. Open it in Scene Builder to modify it. <br>
Events from main.fxml are handled by MainController.java. See the comments in MainController.java for more details<br>

[Model]: src/main/java/sample/model
[Controller]: src/main/java/sample/controller
[Resources]: src/main/java/resources

Adding custom rule families
---------------------------
All custom rules families will inherit from the abstract RuleFamily class in 
[RuleFamily.java](src/main/java/sample/model/rules/RuleFamily.java).

The rule families must use rulestrings to store data. 
They will need to generate regexes to help differentiate them from other rules families<br>
Any additional data that cannot be feasible stored in a rulestring will need to be generated as RLE comments and 
they will be appended to the RLE pattern files.

They must implement the following methods
```java
public abstract class RuleFamily extends Rule implements Cloneable {
    // Loads the rulestring
    public abstract void fromRulestring(String rulestring);

    // Canonises the rulestring
    public abstract String canonise(String rulestring);

    // Returns the regexes to identify the rule family
    public abstract String[] getRegex();

    // Get description of this rule family
    public abstract String getDescription();

    // Randomise rule between minimum and maximum rules
    // Throw IllegalArgumentException if the rule families are not the correct type
    public abstract void randomise(RuleFamily minRule, RuleFamily maxRule) throws IllegalArgumentException;

    // Output false if not successful, true if successful
    // Generates apgtable for apgsearch to use
    // Override if you want to support apgtable generation for this rule family
    // Throw UnsupportedOperationException if apgtable generation for that specific rule is unsupported
    public boolean generateApgtable(File file) throws UnsupportedOperationException {
        throw new UnsupportedOperationException("Apgtable generation is not supported for this rule family");
    }

    // Generates comments that will be placed in the RLE
    // These comments represent additional information that is not stored in the rulestring (e.g. weights)
    // Returned array to be something like {"#R 1 2 3 2 1", "#R 2 4 6 4 2"}
    // Must use "#R" to start!
    // If there isn't anything to add, just return null
    public abstract String[] generateComments();

    // Loads the RLE comments that are generated by generateComments
    public abstract void loadComments(String[] comments);
}
```

as well as these methods from the abstract [Rule.java](src/main/java/sample/model/rules/Rule.java).
```java
public abstract class Rule {
    public abstract Coordinate[] getNeighbourhood(int generation);
    public abstract int transitionFunc(int[] neighbours, int cellState, int generations);
    
    // May be helpful to override for specific cases
    public Color getColor(int state);  // Override for custom colour palette
    public void step(Grid grid, HashSet<Coordinate> cellsChanged, int generation);  // Override for more specific stuff
}
```

For example, take a look at the rule families found [here](src/main/java/sample/model/rules).

Then, create a rule dialog that extends from the abstract [RuleWidget.java](src/main/java/sample/controller/dialogs/RuleWidget.java).

It will need to implement the following method which updates the *ruleFamily* attribute with the relevant information.
```java
public abstract class RuleWidget extends GridPane {
    // Updates the rule with the necessary information
    public abstract void updateRule(String rulestring);
}
```

You may also add other widgets as part of this rule dialog. Some useful predefined widgets would be:
- [x] [NeighbourhoodSelector.java](src/main/java/sample/controller/NeighbourhoodSelector.java)
- [ ] State Weights Selector

Finally, add the new rule widget to [RuleDialog.java](src/main/java/sample/controller/dialogs/RuleDialog.java). <br>
For example,
```java
// Array to store rule widgets
private final RuleWidget[] ruleWidgets = new RuleWidget[]{new HROTDialog(), new YourDialog()};
```

Adding custom neighbourhoods types
----------------------------------
1. Add a generator function in [NeighbourhoodGenerator.java](src/main/java/sample/model/NeighbourhoodGenerator.java). 
It should generate an array of Coordinates.
2. Add a new case in the switch in the *generateFromSymbol* method.
3. If the neighbourhood has weights, add another generator function for the weights. 
It should generate an array of integers which correspond to the weights of each of the 
coordinates in the first generator function.
4. Add a new case in the switch in the *generateWeightsFromSymbol* method.
5. Finally, add the symbol used to the static *neighbourhoodSymbols* variable.
