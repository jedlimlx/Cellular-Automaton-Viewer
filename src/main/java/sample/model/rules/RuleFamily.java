package sample.model.rules;

import com.fasterxml.jackson.annotation.JsonIgnore;
import org.javatuples.Pair;
import sample.model.Coordinate;
import sample.model.Utils;
import sample.model.simulation.Grid;

import java.util.*;

/**
 * Represents a family of rules or a rulespace
 */
public abstract class RuleFamily extends Rule implements Cloneable {
    /**
     * Name of the Rule Family (displayed in the RuleDialog)
     */
    protected String name;

    /**
     * Rulestring of the Rule Family
     */
    protected String rulestring;

    /**
     * Loads the rule's parameters from a rulestring
     * @param rulestring The rulestring of the rule (eg. B3/S23, R2,C2,S5-9,B7-8,NM)
     * @throws IllegalArgumentException Thrown if an invalid rulestring is passed in
     */
    protected abstract void fromRulestring(String rulestring);

    /**
     * Canonises the inputted rulestring with the currently loaded parameters.
     * This method should be called whenever the parameters of a rule are updated.
     * @param rulestring The rulestring to canonised
     * @return Canonised rulestring
     */
    public abstract String canonise(String rulestring);

    /**
     * Sets the rulestring of the rule family to the inputted value
     * @param rulestring Rulestring of the rule
     */
    public void setRulestring(String rulestring) {
        this.boundedGrid = Utils.getBoundedGrid(rulestring);
        this.readingOrder = Utils.getReadingOrder(rulestring);

        rulestring = rulestring.split(":")[0];
        fromRulestring(rulestring);
        this.rulestring = canonise(rulestring);
    }

    /**
     * Updates the background of the rule based on the loaded parameters.
     * This method should be called whenever the parameters of a rule are updated.
     * For non-strobing rules, the background is {0}.
     */
    public void updateBackground() {
        int generations = 0;
        int currentState = 0;
        ArrayList<Pair<Integer, Integer>> bgStates = new ArrayList<>();
        while (!bgStates.contains(new Pair<>(currentState, generations % alternatingPeriod))) {
            bgStates.add(new Pair<>(currentState, generations % alternatingPeriod));

            int[] neighbours = new int[getNeighbourhood().length];
            Arrays.fill(neighbours, currentState);
            currentState = transitionFunc(neighbours, currentState, generations, new Coordinate());

            generations++;
        }

        Pair<Integer, Integer> stateGenerationPair = new Pair<>(currentState, generations % alternatingPeriod);

        int[] background = new int[bgStates.size() - bgStates.indexOf(stateGenerationPair)];
        for (int i = bgStates.indexOf(stateGenerationPair); i < bgStates.size(); i++) {
            background[i - bgStates.indexOf(stateGenerationPair)] = bgStates.get(i).getValue0();
        }

        alternatingPeriod = background.length;

        this.background = new int[background.length];
        int startingIndex = bgStates.indexOf(stateGenerationPair);
        for (int i = startingIndex; i < background.length + startingIndex; i++) {
            this.background[i % background.length] = background[i - startingIndex];
        }
    }

    /**
     * The regexes that will match a valid rulestring
     * @return An array of regexes that will match a valid rulestring
     */
    @JsonIgnore
    public abstract String[] getRegex();

    /**
     * Returns a plain text description of the rule family to be displayed in the Rule Dialog
     * @return Description of the rule family
     */
    @JsonIgnore
    public abstract String getDescription();

    /**
     * Gets information about the rule
     * @return Returns information about the rule in a map
     */
    @JsonIgnore
    public Map<String, String> getRuleInfo() {
        LinkedHashMap<String, String> information = new LinkedHashMap<>();
        information.put("Rulestring", rulestring + "");
        information.put("Number of States", numStates + "");
        information.put("Tiling", tiling + "");
        information.put("Background", Arrays.toString(background));
        return information;
    }

    /**
     * Generates comments that will be placed in the RLE.
     * These comments represent additional information that is not stored in the rulestring (e.g. weights)
     * @return An array of comments each starting with "#R" (eg. {"#R 1 2 3 2 1", "#R 2 4 6 4 2"}).
     * If no additional information needs to be added return null or an empty string array.
     */
    public String[] generateComments() {
        return null;
    }

    /**
     * Loads the additional information stored in the comments generated by generateComments
     * An empty array maybe passed in (meaning no comments)
     * @param comments The comments from the RLE (all starting with #R)
     */
    public void loadComments(String[] comments) {}

    /**
     * Clones the object
     * @return A deepcopy of the object
     */
    @Override
    public abstract Object clone();

    /**
     * Gets the name of the rule
     * @return Name of the rule
     */
    public String getName() {
        return name;
    }

    /**
     * Gets the rulestring of the rule
     * @return Rulestring of the rule
     */
    public String getRulestring() {
        if (readingOrder != null && boundedGrid != null) return rulestring + ":" + boundedGrid.getSpecifier() +
                ":N" + readingOrder.getSpecifier();
        else if (boundedGrid != null) return rulestring + ":" + boundedGrid.getSpecifier();
        else return rulestring;
    }

    @Override
    public String toString() {
        return getRulestring();
    }

    /**
     * Gets the list of neighbours with the input state and output state at the first and last index respectively
     * when provided with an evolutionary sequence. Should be used in conjuction with getMinMaxRule.
     * @param grids An array of grids representing an evolutionary sequence
     * @return Returns the list of neighbours
     */
    protected ArrayList<int[]> getNeighbourList(Grid[] grids) {
        // TODO (Support naive rules)
        ArrayList<int[]> neighboursList = new ArrayList<>();

        // Running through every generation and check what transitions are required
        for (int i = 0; i < grids.length - 1; i++) {
            grids[i].updateBounds();  // Getting the bounds of the grid
            Pair<Coordinate, Coordinate> bounds = grids[i].getBounds();

            Coordinate coordinate, neighbour;  // Current coordinate
            Coordinate[] neighbourhood = getNeighbourhood(i);

            // Inverting neighbourhood for triangular rules
            Coordinate[] invertedNeighbourhood = new Coordinate[neighbourhood.length];
            if (tiling == Tiling.Triangular) {
                for (int j = 0; j < neighbourhood.length; j++) {
                    invertedNeighbourhood[j] = new Coordinate(neighbourhood[j].getX(), -neighbourhood[j].getY());
                }
            }

            for (int x = bounds.getValue0().getX() - 5; x < bounds.getValue1().getX() + 5; x++) {
                for (int y = bounds.getValue0().getY() - 5; y < bounds.getValue1().getY() + 5; y++) {
                    coordinate = new Coordinate(x, y);
                    if (dependsOnNeighbours(grids[i].getCell(coordinate), i, coordinate) != -1) continue;

                    // Apply the bounded grid
                    if (boundedGrid != null && boundedGrid.atEdge(coordinate))
                        coordinate = boundedGrid.map(coordinate);

                    // Computes the neighbourhood sum for every cell
                    int[] neighbours = new int[getNeighbourhood(i).length + 2];
                    if (tiling != Tiling.Triangular ||
                            Math.floorMod(coordinate.getX(), 2) == Math.floorMod(coordinate.getY(), 2)) {
                        for (int j = 0; j < neighbourhood.length; j++) {
                            neighbour = coordinate.add(neighbourhood[j]);

                            // Apply the bounded grid
                            if (boundedGrid != null && boundedGrid.atEdge(neighbour))
                                neighbour = boundedGrid.map(neighbour);

                            neighbours[j + 1] = grids[i].getCell(neighbour);
                        }
                    }
                    else {
                        for (int j = 0; j < neighbourhood.length; j++) {
                            neighbour = coordinate.add(invertedNeighbourhood[j]);

                            // Apply the bounded grid
                            if (boundedGrid != null && boundedGrid.atEdge(neighbour))
                                neighbour = boundedGrid.map(neighbour);

                            neighbours[j + 1] = grids[i].getCell(neighbour);
                        }
                    }

                    neighbours[0] = grids[i].getCell(coordinate);
                    neighbours[neighbourhood.length + 1] = grids[i + 1].getCell(coordinate);

                    neighboursList.add(neighbours);
                }
            }
        }

        return neighboursList;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        RuleFamily that = (RuleFamily) o;
        return Objects.equals(rulestring, that.rulestring);
    }

    @Override
    public int hashCode() {
        return Objects.hash(rulestring);
    }
}
