import re
from libs import RuleParser
from CAComputeParse.R1_INT_Moore import get_trans_moore
from CAComputeParse.R2_INT_Cross import get_trans_cross
from CAComputeParse.R2_INT_FarCorners import get_trans_far
from CAComputeParse.R2_INT_Von_Neumann import get_trans_von_neumann
from CAComputeParse.R2_INT_Knight import get_trans_knight


def gen_ot(string: str):
    all_trans = []
    for i in string.split(b","):
        trans = []
        for j in range(len(RuleParser.neighbourhood[0])):
            if j < int(i):
                trans.append(1)
            else:
                trans.append(0)

        all_trans.append(trans)

    return all_trans


def gen_apgtable(filename: str):
    if RuleParser.bs_conditions == "Range 1 Moore Isotropic Non-Totalistic":
        neighbourhood = [[(1, -1), (1, 0), (1, 1), (0, 1),
                          (-1, 1), (-1, 0), (-1, -1), (0, -1)]]
    elif RuleParser.bs_conditions == "Range 2 Cross Isotropic Non-Totalistic":
        neighbourhood = [[(2, 0), (0, 2), (-2, 0), (0, -2),
                          (1, 0), (0, 1), (-1, 0), (0, -1)]]
    elif RuleParser.bs_conditions == "Range 2 Von Neumann Isotropic Non-Totalistic":
        neighbourhood = [[(1, -1), (1, 0), (1, 1), (0, 1),
                          (-1, 1), (-1, 0), (-1, -1), (0, -1),
                          (2, 0), (0, 2), (-2, 0), (0, -2)]]
    elif RuleParser.bs_conditions == "Range 2 Far Corners Isotropic Non-Totalistic":
        neighbourhood = [[(2, -2), (1, 0), (2, 2), (0, 1),
                          (-2, 2), (-1, 0), (-2, -2), (0, -1)]]
    elif RuleParser.bs_conditions == "Range 2 Knight Isotropic Non-Totalistic":
        neighbourhood = [[(1, -2), (2, -1), (2, 1), (1, 2),
                          (-1, 2), (-2, 1), (-2, -1), (-1, -2)]]
    else:
        neighbourhood = RuleParser.neighbourhood

    apgtable_file = open(filename, "w+")
    apgtable_file.write("# This ruletable is automatically generated by CAViewer.\n\n")
    apgtable_file.write(f"n_states:{RuleParser.n_states}\n")
    apgtable_file.write(f"neighborhood:{[(0, 0)] + neighbourhood[0] + [(0, 0)]}\n")
    apgtable_file.write(f"symmetries:{'none' if RuleParser.bs_conditions != 'Outer Totalistic' else 'permute'}\n")

    if RuleParser.rulespace == "Single State":
        if "/" in RuleParser.rule_string[0]:  # Getting the birth and survival strings
            birth_string = RuleParser.rule_string[0].split("/")[1]
            survival_string = RuleParser.rule_string[0].split("/")[0]
        else:
            birth_string = re.split("[bs]", RuleParser.rule_string[0].lower())[1]
            survival_string = re.split("[bs]", RuleParser.rule_string[0].lower())[2]

        # Writing variables for death transition
        apgtable_file.write(f"\n# Variables for Death Transitions\n")
        for i in range(len(neighbourhood[0])):
            apgtable_file.write(f"var death{i} = " + "{0, 1}\n")

        if RuleParser.bs_conditions == "Range 1 Moore Isotropic Non-Totalistic":
            apgtable_file.write("\n# Birth Transitions\n")
            for trans in get_trans_moore(birth_string.encode("utf-8")):
                apgtable_file.write("0," + ",".join([str(x) for x in trans]) + ",1\n")

            apgtable_file.write("\n# Survival Transitions\n")
            for trans in get_trans_moore(survival_string.encode("utf-8")):
                apgtable_file.write("1," + ",".join([str(x) for x in trans]) + ",1\n")

        elif RuleParser.bs_conditions == "Range 2 Cross Isotropic Non-Totalistic":
            apgtable_file.write("\n# Birth Transitions\n")
            for trans in get_trans_cross(birth_string.encode("utf-8")):
                apgtable_file.write("0," + ",".join([str(x) for x in trans]) + ",1\n")

            apgtable_file.write("\n# Survival Transitions\n")
            for trans in get_trans_cross(survival_string.encode("utf-8")):
                apgtable_file.write("1," + ",".join([str(x) for x in trans]) + ",1\n")

        elif RuleParser.bs_conditions == "Range 2 Von Neumann Isotropic Non-Totalistic":
            apgtable_file.write("\n# Birth Transitions\n")
            for trans in get_trans_von_neumann(birth_string.encode("utf-8")):
                apgtable_file.write("0," + ",".join([str(x) for x in trans]) + ",1\n")

            apgtable_file.write("\n# Survival Transitions\n")
            for trans in get_trans_von_neumann(survival_string.encode("utf-8")):
                apgtable_file.write("1," + ",".join([str(x) for x in trans]) + ",1\n")

        elif RuleParser.bs_conditions == "Range 2 Far Corners Isotropic Non-Totalistic":
            apgtable_file.write("\n# Birth Transitions\n")
            for trans in get_trans_far(birth_string.encode("utf-8")):
                apgtable_file.write("0," + ",".join([str(x) for x in trans]) + ",1\n")

            apgtable_file.write("\n# Survival Transitions\n")
            for trans in get_trans_far(survival_string.encode("utf-8")):
                apgtable_file.write("1," + ",".join([str(x) for x in trans]) + ",1\n")

        elif RuleParser.bs_conditions == "Range 2 Knight Isotropic Non-Totalistic":
            apgtable_file.write("\n# Birth Transitions\n")
            for trans in get_trans_knight(birth_string.encode("utf-8")):
                apgtable_file.write("0," + ",".join([str(x) for x in trans]) + ",1\n")

            apgtable_file.write("\n# Survival Transitions\n")
            for trans in get_trans_knight(survival_string.encode("utf-8")):
                apgtable_file.write("1," + ",".join([str(x) for x in trans]) + ",1\n")

        elif RuleParser.bs_conditions == "Outer Totalistic":
            apgtable_file.write("\n# Birth Transitions\n")
            for trans in gen_ot(birth_string.encode("utf-8")):
                apgtable_file.write("0," + ",".join([str(x) for x in trans]) + ",1\n")

            apgtable_file.write("\n# Survival Transitions\n")
            for trans in gen_ot(survival_string.encode("utf-8")):
                apgtable_file.write("1," + ",".join([str(x) for x in trans]) + ",1\n")

        apgtable_file.write("\n# Death Transitions\n")
        apgtable_file.write(f"1,{','.join([f'death{x}' for x in range(len(neighbourhood[0]))])},0")
    elif RuleParser.rulespace == "Extended Generations":
        if "/" in RuleParser.rule_string[0]:  # Getting the birth and survival strings
            birth_string = RuleParser.rule_string[0].split("/")[1]
            survival_string = RuleParser.rule_string[0].split("/")[0]
            extended = RuleParser.rule_string[0].split("/")[2].split("-")
        else:
            birth_string = re.split("[bsd]", RuleParser.rule_string[0].lower())[1]
            survival_string = re.split("[bsd]", RuleParser.rule_string[0].lower())[2]
            extended = re.split("[bsd]", RuleParser.rule_string[0].lower())[3].split("-")

        num, alt = 1, 1
        activity = []
        inactivity = ['0']
        for i in extended:
            for j in range(num, int(i) + num):
                if alt > 0:
                    activity.append(str(j))
                else:
                    inactivity.append(str(j))
                num += 1

            alt *= -1

        # Activity Vars
        apgtable_file.write("\n# Activity Variables\n")
        for i in range(len(neighbourhood[0])):
            apgtable_file.write(f"var active{i} = {{{', '.join(activity)}}}\n")

        # Inactivity Vars
        apgtable_file.write("\n# Inactivity Variables\n")
        for i in range(len(neighbourhood[0])):
            apgtable_file.write(f"var inactive{i} = {{{', '.join(inactivity)}}}\n")

        # Decay Vars
        apgtable_file.write(f"\n# Decay Variables\n")
        for i in range(len(neighbourhood[0])):
            apgtable_file.write(f"var decay{i} = {{{', '.join([str(x) for x in range(RuleParser.n_states)])}}}\n")

        if RuleParser.bs_conditions == "Range 1 Moore Isotropic Non-Totalistic":
            apgtable_file.write("\n# Birth Transitions\n")
            for trans in get_trans_moore(birth_string.encode("utf-8")):
                string = ""
                for i in range(len(trans)):
                    if i != len(trans) - 1:
                        if trans[i] == 0: string += f"inactive{i},"
                        else: string += f"active{i},"
                    else:
                        if trans[i] == 0: string += f"inactive{i}"
                        else: string += f"active{i}"

                apgtable_file.write(f"0,{string},1\n")

            apgtable_file.write("\n# Survival Transitions\n")
            for state in activity:
                for trans in get_trans_moore(survival_string.encode("utf-8")):
                    string = ""
                    for i in range(len(trans)):
                        if i != len(trans) - 1:
                            if trans[i] == 0: string += f"inactive{i},"
                            else: string += f"active{i},"
                        else:
                            if trans[i] == 0: string += f"inactive{i}"
                            else: string += f"active{i}"

                    apgtable_file.write(f"{state},{string},{state}\n")

        elif RuleParser.bs_conditions == "Range 2 Cross Isotropic Non-Totalistic":
            apgtable_file.write("\n# Birth Transitions\n")
            for trans in get_trans_cross(birth_string.encode("utf-8")):
                string = ""
                for i in range(len(trans)):
                    if i != len(trans) - 1:
                        if trans[i] == 0:
                            string += f"inactive{i},"
                        else:
                            string += f"active{i},"
                    else:
                        if trans[i] == 0:
                            string += f"inactive{i}"
                        else:
                            string += f"active{i}"

                apgtable_file.write(f"0,{string},1\n")

            apgtable_file.write("\n# Survival Transitions\n")
            for state in activity:
                for trans in get_trans_cross(survival_string.encode("utf-8")):
                    string = ""
                    for i in range(len(trans)):
                        if i != len(trans) - 1:
                            if trans[i] == 0: string += f"inactive{i},"
                            else: string += f"active{i},"
                        else:
                            if trans[i] == 0: string += f"inactive{i}"
                            else: string += f"active{i}"

                    apgtable_file.write(f"{state},{string},{state}\n")

        elif RuleParser.bs_conditions == "Range 2 Von Neumann Isotropic Non-Totalistic":
            apgtable_file.write("\n# Birth Transitions\n")
            for trans in get_trans_von_neumann(birth_string.encode("utf-8")):
                string = ""
                for i in range(len(trans)):
                    if i != len(trans) - 1:
                        if trans[i] == 0: string += f"inactive{i},"
                        else: string += f"active{i},"
                    else:
                        if trans[i] == 0: string += f"inactive{i}"
                        else: string += f"active{i}"

                apgtable_file.write(f"0,{string},1\n")

            apgtable_file.write("\n# Survival Transitions\n")
            for state in activity:
                for trans in get_trans_von_neumann(survival_string.encode("utf-8")):
                    string = ""
                    for i in range(len(trans)):
                        if i != len(trans) - 1:
                            if trans[i] == 0: string += f"inactive{i},"
                            else: string += f"active{i},"
                        else:
                            if trans[i] == 0: string += f"inactive{i}"
                            else: string += f"active{i}"

                    apgtable_file.write(f"{state},{string},{state}\n")

        elif RuleParser.bs_conditions == "Range 2 Far Corners Isotropic Non-Totalistic":
            apgtable_file.write("\n# Birth Transitions\n")
            for trans in get_trans_far(birth_string.encode("utf-8")):
                string = ""
                for i in range(len(trans)):
                    if i != len(trans) - 1:
                        if trans[i] == 0: string += f"inactive{i},"
                        else: string += f"active{i},"
                    else:
                        if trans[i] == 0: string += f"inactive{i}"
                        else: string += f"active{i}"

                apgtable_file.write(f"0,{string},1\n")

            apgtable_file.write("\n# Survival Transitions\n")
            for state in activity:
                for trans in get_trans_far(survival_string.encode("utf-8")):
                    string = ""
                    for i in range(len(trans)):
                        if i != len(trans) - 1:
                            if trans[i] == 0: string += f"inactive{i},"
                            else: string += f"active{i},"
                        else:
                            if trans[i] == 0: string += f"inactive{i}"
                            else: string += f"active{i}"

                    apgtable_file.write(f"{state},{string},{state}\n")

        elif RuleParser.bs_conditions == "Range 2 Knight Isotropic Non-Totalistic":
            apgtable_file.write("\n# Birth Transitions\n")
            for trans in get_trans_knight(birth_string.encode("utf-8")):
                string = ""
                for i in range(len(trans)):
                    if i != len(trans) - 1:
                        if trans[i] == 0:
                            string += f"inactive{i},"
                        else:
                            string += f"active{i},"
                    else:
                        if trans[i] == 0:
                            string += f"inactive{i}"
                        else:
                            string += f"active{i}"

                apgtable_file.write(f"0,{string},1\n")

            apgtable_file.write("\n# Survival Transitions\n")
            for state in activity:
                for trans in get_trans_knight(survival_string.encode("utf-8")):
                    string = ""
                    for i in range(len(trans)):
                        if i != len(trans) - 1:
                            if trans[i] == 0:
                                string += f"inactive{i},"
                            else:
                                string += f"active{i},"
                        else:
                            if trans[i] == 0:
                                string += f"inactive{i}"
                            else:
                                string += f"active{i}"

                    apgtable_file.write(f"{state},{string},{state}\n")

        elif RuleParser.bs_conditions == "Outer Totalistic":
            apgtable_file.write("\n# Birth Transitions\n")
            for trans in gen_ot(birth_string.encode("utf-8")):
                string = ""
                for i in range(len(trans)):
                    if i != len(trans) - 1:
                        if trans[i] == 0: string += f"inactive{i},"
                        else: string += f"active{i},"
                    else:
                        if trans[i] == 0: string += f"inactive{i}"
                        else: string += f"active{i}"

                apgtable_file.write(f"0,{string},1\n")

            apgtable_file.write("\n# Survival Transitions\n")
            for state in activity:
                for trans in gen_ot(survival_string.encode("utf-8")):
                    string = ""
                    for i in range(len(trans)):
                        if i != len(trans) - 1:
                            if trans[i] == 0: string += f"inactive{i},"
                            else: string += f"active{i},"
                        else:
                            if trans[i] == 0: string += f"inactive{i}"
                            else: string += f"active{i}"

                    apgtable_file.write(f"{state},{string},{state}\n")

        apgtable_file.write("\n# Decay Transitions\n")
        for i in range(1, RuleParser.n_states):
            apgtable_file.write(f"{i},{','.join([f'decay{x}' for x in range(len(neighbourhood[0]))])},"
                                f"{(i + 1) % RuleParser.n_states}\n")
    elif RuleParser.rulespace == "BSFKL":
        if "/" in RuleParser.rule_string[0]:  # Getting the birth and survival strings
            birth_string = RuleParser.rule_string[0].split("/")[0]
            survival_string = RuleParser.rule_string[0].split("/")[1]
            forcing_string = RuleParser.rule_string[0].split("/")[2]
            killing_string = RuleParser.rule_string[0].split("/")[3]
            living_string = RuleParser.rule_string[0].split("/")[4]
        else:
            birth_string = re.split("[bs]", RuleParser.rule_string[0].lower())[1]
            survival_string = re.split("[bs]", RuleParser.rule_string[0].lower())[2]
            forcing_string = re.split("[bs]", RuleParser.rule_string[0].lower())[3]
            killing_string = re.split("[bs]", RuleParser.rule_string[0].lower())[4]
            living_string = re.split("[bs]", RuleParser.rule_string[0].lower())[5]

        # Writing variables for death transition
        apgtable_file.write(f"\n# Variables for Any State\n")
        for i in range(len(neighbourhood[0])):
            apgtable_file.write(f"var any{i} = " + "{0, 1, 2}\n")

        # Writing variables for death transition
        apgtable_file.write(f"\n# Variables for Dead or Alive\n")
        for i in range(len(neighbourhood[0])):
            apgtable_file.write(f"var live{i} = " + "{0, 1}\n")

        # Writing variables for death transition
        apgtable_file.write(f"\n# Variables for Dead or Destructive\n")
        for i in range(len(neighbourhood[0])):
            apgtable_file.write(f"var destruct{i} = " + "{0, 2}\n")

        if RuleParser.bs_conditions == "Range 1 Moore Isotropic Non-Totalistic":
            trans_birth = get_trans_moore(birth_string.encode("utf-8"))
            trans_survival = get_trans_moore(survival_string.encode("utf-8"))
            trans_forcing = get_trans_moore(forcing_string.encode("utf-8"))
            trans_killing = get_trans_moore(killing_string.encode("utf-8"))
            trans_living = get_trans_moore(living_string.encode("utf-8"))
        elif RuleParser.bs_conditions == "Range 2 Von Neumann Isotropic Non-Totalistic":
            trans_birth = get_trans_von_neumann(birth_string.encode("utf-8"))
            trans_survival = get_trans_von_neumann(survival_string.encode("utf-8"))
            trans_forcing = get_trans_von_neumann(forcing_string.encode("utf-8"))
            trans_killing = get_trans_von_neumann(killing_string.encode("utf-8"))
            trans_living = get_trans_von_neumann(living_string.encode("utf-8"))
        elif RuleParser.bs_conditions == "Range 2 Far Corners Isotropic Non-Totalistic":
            trans_birth = get_trans_far(birth_string.encode("utf-8"))
            trans_survival = get_trans_far(survival_string.encode("utf-8"))
            trans_forcing = get_trans_far(forcing_string.encode("utf-8"))
            trans_killing = get_trans_far(killing_string.encode("utf-8"))
            trans_living = get_trans_far(living_string.encode("utf-8"))
        elif RuleParser.bs_conditions == "Range 2 Cross Isotropic Non-Totalistic":
            trans_birth = get_trans_cross(birth_string.encode("utf-8"))
            trans_survival = get_trans_cross(survival_string.encode("utf-8"))
            trans_forcing = get_trans_cross(forcing_string.encode("utf-8"))
            trans_killing = get_trans_cross(killing_string.encode("utf-8"))
            trans_living = get_trans_cross(living_string.encode("utf-8"))
        elif RuleParser.bs_conditions == "Range 2 Knight Isotropic Non-Totalistic":
            trans_birth = get_trans_knight(birth_string.encode("utf-8"))
            trans_survival = get_trans_knight(survival_string.encode("utf-8"))
            trans_forcing = get_trans_knight(forcing_string.encode("utf-8"))
            trans_killing = get_trans_knight(killing_string.encode("utf-8"))
            trans_living = get_trans_knight(living_string.encode("utf-8"))
        else:
            trans_birth = gen_ot(birth_string.encode("utf-8"))
            trans_survival = gen_ot(survival_string.encode("utf-8"))
            trans_forcing = gen_ot(forcing_string.encode("utf-8"))
            trans_killing = gen_ot(killing_string.encode("utf-8"))
            trans_living = gen_ot(living_string.encode("utf-8"))

        apgtable_file.write("\n# Birth Transitions\n")
        for i in trans_birth:
            for j in trans_forcing:
                # Merging the 2 transitions
                new_trans = []
                for x in range(len(i)):
                    if i[x] == j[x] == 1: break
                    if i[x] == 1:
                        new_trans.append("1")
                    elif j[x] == 1:
                        new_trans.append("2")
                    else:
                        new_trans.append("0")
                else:
                    apgtable_file.write("0, " + ", ".join(new_trans) + ", 1\n")
                continue  # Transitions can't be merged try different ones

        apgtable_file.write("\n# State 1 Death Transitions\n")
        for i in trans_killing:
            apgtable_file.write("1, " + ", ".join(["2" if i[x] == 1 else f"live{x}"
                                                   for x in range(len(i))]) + ", 0\n")

        apgtable_file.write("\n# State 1 Survival Transitions\n")
        for i in trans_survival:
            apgtable_file.write("1, " + ", ".join(["1" if i[x] == 1 else f"destruct{x}"
                                                   for x in range(len(i))]) + ", 1\n")

        apgtable_file.write("\n# State 2 Death Transitions\n")
        for i in trans_living:
            apgtable_file.write("2, " + ", ".join(["1" if i[x] == 1 else f"destruct{x}"
                                                   for x in range(len(i))]) + ", 0\n")

        apgtable_file.write("\n# State 1 -> State 2\n")
        apgtable_file.write(f"1,{','.join([f'any{x}' for x in range(len(neighbourhood[0]))])},2\n")

        apgtable_file.write("\n# State 2 Survival Transitions\n")
        apgtable_file.write(f"2,{','.join([f'any{x}' for x in range(len(neighbourhood[0]))])},2\n")
    elif RuleParser.bs_conditions == "Regenerating Generations":
        if "/" in RuleParser.rule_string[0]:  # Getting the birth and survival strings
            birth_string = RuleParser.rule_string[0].split("/")[2]
            survival_string = RuleParser.rule_string[0].split("/")[3]
            regen_birth_string = RuleParser.rule_string[0].split("/")[4]
            regen_survival_string = RuleParser.rule_string[0].split("/")[5]
        else:
            birth_string = re.split("rg|l|b|s|rb|rs", RuleParser.rule_string[0].lower())[3]
            survival_string = re.split("rg|l|b|s|rb|rs", RuleParser.rule_string[0].lower())[4]
            regen_birth_string = re.split("rg|l|b|s|rb|rs", RuleParser.rule_string[0].lower())[5]
            regen_survival_string = re.split("rg|l|b|s|rb|rs", RuleParser.rule_string[0].lower())[6]

        apgtable_file.write(f"\n# Decay Variables\n")
        for i in range(len(neighbourhood[0])):
            apgtable_file.write(f"var decay{i} = {{{', '.join([str(x) for x in range(RuleParser.n_states)])}}}\n")

        apgtable_file.write(f"\nVariables for Dying States\n")
        for i in range(neighbourhood[0]):
            apgtable_file.write(
                f"var dying{i} = {{{', '.join([str(x) for x in range(RuleParser.n_states) if x != 1])}}}\n")

        if RuleParser.bs_conditions == "Range 1 Moore Isotropic Non-Totalistic":
            trans_birth = get_trans_moore(birth_string.encode("utf-8"))
            trans_survival = get_trans_moore(survival_string.encode("utf-8"))
            trans_regen_birth = get_trans_moore(regen_birth_string.encode("utf-8"))
            trans_regen_survival = get_trans_moore(regen_survival_string.encode("utf-8"))
        elif RuleParser.bs_conditions == "Range 2 Von Neumann Isotropic Non-Totalistic":
            trans_birth = get_trans_von_neumann(birth_string.encode("utf-8"))
            trans_survival = get_trans_von_neumann(survival_string.encode("utf-8"))
            trans_regen_birth = get_trans_von_neumann(regen_birth_string.encode("utf-8"))
            trans_regen_survival = get_trans_von_neumann(regen_survival_string.encode("utf-8"))
        elif RuleParser.bs_conditions == "Range 2 Cross Isotropic Non-Totalistic":
            trans_birth = get_trans_cross(birth_string.encode("utf-8"))
            trans_survival = get_trans_cross(survival_string.encode("utf-8"))
            trans_regen_birth = get_trans_cross(regen_birth_string.encode("utf-8"))
            trans_regen_survival = get_trans_cross(regen_survival_string.encode("utf-8"))
        elif RuleParser.bs_conditions == "Range 2 Far Corners Isotropic Non-Totalistic":
            trans_birth = get_trans_far(birth_string.encode("utf-8"))
            trans_survival = get_trans_far(survival_string.encode("utf-8"))
            trans_regen_birth = get_trans_far(regen_birth_string.encode("utf-8"))
            trans_regen_survival = get_trans_far(regen_survival_string.encode("utf-8"))
        elif RuleParser.bs_conditions == "Range 2 Knight Isotropic Non-Totalistic":
            trans_birth = get_trans_knight(birth_string.encode("utf-8"))
            trans_survival = get_trans_knight(survival_string.encode("utf-8"))
            trans_regen_birth = get_trans_knight(regen_birth_string.encode("utf-8"))
            trans_regen_survival = get_trans_knight(regen_survival_string.encode("utf-8"))
        else:
            trans_birth = gen_ot(birth_string.encode("utf-8"))
            trans_survival = gen_ot(survival_string.encode("utf-8"))
            trans_regen_birth = gen_ot(regen_birth_string.encode("utf-8"))
            trans_regen_survival = gen_ot(regen_survival_string.encode("utf-8"))

        apgtable_file.write(f"\n# State 1 Birth Transitions\n")
        for transition in trans_birth:
            string = ""
            for i in range(len(transition)):
                if transition[i] == 0: string += f"dying{i}, "
                else: string += "1, "
            apgtable_file.write(f"0, {string}, 1")

        apgtable_file.write(f"\n# State 1 Survival Transitions\n")
        for transition in trans_survival:
            string = ""
            for i in range(len(transition)):
                if transition[i] == 0: string += f"dying{i}, "
                else: string += "1, "
            apgtable_file.write(f"1, {string}, 1")

        for state in range(2, RuleParser.n_states):
            string = ""
            apgtable_file.write(f"\n# State {state} Regeneration Transitions\n")
            for transition in trans_regen_birth:
                for i in range(len(transition)):
                    if transition[i] == 0:
                        string += f"dying{i}, "
                    else:
                        string += "1, "
                apgtable_file.write(f"{state}, {string}, {state - 1}")

            string = ""
            apgtable_file.write(f"\n# State {state} Survival Transitions\n")
            for transition in trans_regen_survival:
                for i in range(len(transition)):
                    if transition[i] == 0:
                        string += f"dying{i}, "
                    else:
                        string += "1, "
                apgtable_file.write(f"{state}, {string}, {state}")

            apgtable_file.write("\n# Decay Transitions\n")
            apgtable_file.write(f"{state}, {','.join([f'decay{x}' for x in range(len(neighbourhood[0]))])}, "
                                f"{(state + 1) % RuleParser.n_states}")

        apgtable_file.write(f"1, {','.join([f'decay{x}' for x in range(len(neighbourhood[0]))])}, 2")

    apgtable_file.close()
